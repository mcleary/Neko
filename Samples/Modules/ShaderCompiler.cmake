if(NEKO_GENERATE_MODE)
    function(WRAP_STRING)
        set(oneValueArgs VARIABLE AT_COLUMN)
        cmake_parse_arguments(WRAP_STRING "${options}" "${oneValueArgs}" "" ${ARGN})

        string(LENGTH ${${WRAP_STRING_VARIABLE}} stringLength)
        math(EXPR offset "0")

        while(stringLength GREATER 0)

            if(stringLength GREATER ${WRAP_STRING_AT_COLUMN})
                math(EXPR length "${WRAP_STRING_AT_COLUMN}")
            else()
                math(EXPR length "${stringLength}")
            endif()

            string(SUBSTRING ${${WRAP_STRING_VARIABLE}} ${offset} ${length} line)
            set(lines "${lines}\n${line}")

            math(EXPR stringLength "${stringLength} - ${length}")
            math(EXPR offset "${offset} + ${length}")
        endwhile()

        set(${WRAP_STRING_VARIABLE} "${lines}" PARENT_SCOPE)
    endfunction()

    file(READ ${INPUT_FILE} hexString HEX)
    string(LENGTH ${hexString} hexStringLength)

    # wraps the hex string into multiple lines at column 32(i.e. 16 bytes per line)
    wrap_string(VARIABLE hexString AT_COLUMN 32)
    math(EXPR arraySize "${hexStringLength} / 2")

    # adds '0x' prefix and comma suffix before and after every byte respectively
    string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1, " arrayValues ${hexString})

    # removes trailing comma
    string(REGEX REPLACE ", $" "" arrayValues ${arrayValues})

    string(MAKE_C_IDENTIFIER "${SYMBOL}" SYMBOL)

    set(pragmaOnce "#pragma once")
    set(includeDirs "#include <Neko/Neko.h>")
    set(warning "// Warning: this file was generated by ShaderCompiler.cmake. Do not modify it!")
    set(arrayComment "// This header contains the ${TARGET} binary generated from ${SOURCE_FILE}")
    set(arrayDefinition "const uint8_t NK_ALIGN_AS(4) ${NAMESPACE}${SYMBOL}Source[] = { ${arrayValues} };")
    set(arraySizeDefinition "const uint32_t ${NAMESPACE}${SYMBOL}SourceSize = ${arraySize};")

    set(declarations "${pragmaOnce}\n\n${includeDirs}\n\n${warning}\n${arrayComment}\n\n${arrayDefinition}\n\n${arraySizeDefinition}\n\n")

    file(WRITE ${OUTPUT_FILE} "${declarations}")

    return()
endif()

set(NEKO_SHADER_SCRIPT "${CMAKE_CURRENT_LIST_FILE}" CACHE INTERNAL "Path to ShaderCompiler script")

function(add_shader_module name)
    set(options)
    set(oneValueArgs NAME INPUT ENTRY_POINT STAGE)
    set(multiValueArgs)
    cmake_parse_arguments(
        SHADER
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

    get_filename_component(ShaderInput "${CMAKE_CURRENT_SOURCE_DIR}/${SHADER_INPUT}" ABSOLUTE)
    get_filename_component(ShaderHeader "${CMAKE_CURRENT_BINARY_DIR}/Neko/Shaders/${SHADER_NAME}.h" ABSOLUTE)
    get_filename_component(ShaderBin "${CMAKE_CURRENT_BINARY_DIR}/Neko/Shaders/${SHADER_NAME}.bin" ABSOLUTE)

    set_source_files_properties(${SHADER_INPUT} PROPERTIES VS_TOOL_OVERRIDE "None")

    add_custom_target("${SHADER_NAME}" ALL
        ${CMAKE_COMMAND} -E echo "Compiling shaders..."
        DEPENDS ${ShaderHeader}
    )

    # TODO: change target depending on backend. Vulkan only for now.
    set(TARGET spirv)

    add_custom_command(
        OUTPUT  ${ShaderHeader}
        COMMAND ${CMAKE_COMMAND} -E echo "Compiling shader ${ShaderInput}. Generating shader binary header: ${ShaderHeader}"
        COMMAND ShaderConductor -I ${ShaderInput} -O ${ShaderBin} -S ${SHADER_STAGE} -E ${SHADER_ENTRY_POINT} -T ${TARGET}
        COMMAND ${CMAKE_COMMAND} -DNEKO_GENERATE_MODE=TRUE -DNAMESPACE="Nk" -DTARGET=${TARGET} -DSOURCE_FILE=${ShaderInput}
                                 -DSYMBOL=${SHADER_NAME} -DINPUT_FILE=${ShaderBin} -DOUTPUT_FILE=${ShaderHeader}
                                 -P ${NEKO_SHADER_SCRIPT}
        COMMAND ${CMAKE_COMMAND} -E remove ${ShaderBin}
        DEPENDS ${SHADER_INPUT}
    )

    target_sources(${name} PRIVATE ${SHADER_INPUT} ${ShaderHeader})
    target_include_directories(${name} PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
endfunction()
